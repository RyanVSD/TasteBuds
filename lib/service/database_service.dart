import 'package:amplify_api/amplify_api.dart';
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:tastebuds/model/objects/post_item.dart';
import 'package:tastebuds/service/auth_service.dart';
import '../model/amplify/ModelProvider.dart';

class Database {
  static Future<List<AuthUserAttribute>> getUserAttributes() async {
    try {
      final attributes = await Amplify.Auth.fetchUserAttributes();
      return attributes;
    } catch (e) {
      safePrint('Error fetching user attributes: $e');
      return const [];
    }
  }

  static Future<String> getUsername() async {
    try {
      final user = await Amplify.Auth.getCurrentUser();
      return user.username;
    } catch (e) {
      safePrint('Error fetching user id: $e');
      return "";
    }
  }

  static Future<List<User?>> everyUser() async {
    try {
      final firstRequest = ModelQueries.list<User>(User.classType);
      final firstResult =
          await Amplify.API.query(request: firstRequest).response;
      final firstPageData = firstResult.data;
      if (firstPageData?.items == null) {
        print("NULL PAGE: ${firstResult.errors}");
      } else {
        print("GOOD PAGE :) ${firstPageData?.items}");
      }
      return firstPageData?.items ?? <User?>[];
    } on ApiException catch (e) {
      safePrint("cooked: $e");
      return [];
    }
  }

  static Future<List<Post?>> getPosts(int limit) async {
    try {
      final firstRequest =
          ModelQueries.list<Post>(Post.classType, limit: limit);
      final firstResult =
          await Amplify.API.query(request: firstRequest).response;
      final firstPageData = firstResult.data;
      return firstPageData?.items ?? <Post?>[];
    } on ApiException catch (e) {
      safePrint("Error fetching posts: $e");
      return const [];
    }
  }

  static Future<Post?> getPost(String postId) async {
    try {
      final queryPredicate = Post.ID.eq(postId);
      final request = ModelQueries.list(Post.classType, where: queryPredicate);
      final response = await Amplify.API.query(request: request).response;
      final posts = response.data?.items;
      if (posts == null) {
        safePrint("Errors: ${response.errors}");
        return null;
      } else {
        return posts[0];
      }
    } on ApiException catch (e) {
      safePrint("error fetching post: $e");
      return null;
    }
  }

  static Future<Post?> createPost(PostItem toAdd) async {
    try {
      // create the post object to upload
      // Get ingredients formatted to new ingredient obj
      List<Ingredient> ingredients = toAdd.ingredients
          .map((ing) => Ingredient(
              name: ing.getName(),
              value: ing.getValue(),
              unit: Units.values
                  .firstWhere((unit) => unit.name == ing.getUnitType())))
          .toList();

      // Get the user object of the author
      final user = await Amplify.Auth.getCurrentUser();
      final identifier = UserModelIdentifier(id: user.userId);
      final userQuery = ModelQueries.get(User.classType, identifier);
      final userResponse = await Amplify.API.query(request: userQuery).response;
      User? author = userResponse.data;
      if (author == null) {
        throw StateError("no user info: ${userResponse.errors}");
      }

      // Make the post
      Post post = Post(
        title: toAdd.title,
        description: toAdd.description,
        imageUrl: toAdd.imageUrl,
        steps: toAdd.steps,
        likes: 0,
        favorites: 0,
        difficulty: toAdd.difficulty.toDouble(),
        uploadTime: TemporalDateTime(toAdd.uploadTime),
        price: toAdd.price,
        ingredients: ingredients,
        author: author,
      );

      // Create the post mutation
      final request = ModelMutations.create(post);
      final response = await Amplify.API.mutate(request: request).response;
      final createdPost = response.data;

      if (createdPost == null) {
        throw StateError("nuh uh post: ${response.errors}");
      }

      // Now that we have the post id generated by AWS, we can create an associated file path
      // We need to upload the file to that new path, and then update the filePath in the db accordingly

      final postId = createdPost.id;
      final uploadPath = "images/$postId";
      AWSFile file = AWSFile.fromPath(toAdd.imageUrl);
      final uploadResult = await Amplify.Storage.uploadFile(
        localFile: file,
        path: StoragePath.fromString(uploadPath),
      ).result;
      safePrint("Uploaded file at: ${uploadResult.uploadedItem.path}");

      // Update file path in post
      final postWithNewFilePath = createdPost.copyWith(imageUrl: uploadPath);
      final updateRequest = ModelMutations.update(postWithNewFilePath);
      final updateResponse =
          await Amplify.API.mutate(request: updateRequest).response;
      final finalPost = updateResponse.data;

      if (finalPost == null) {
        throw StateError("error updating object: ${updateResponse.errors}");
      }

      return finalPost;
    } on ApiException catch (e) {
      safePrint("Mutation failed: $e");
      return null;
    } on StateError catch (e) {
      safePrint("Mutation failed: $e");
      return null;
    } on StorageException catch (e) {
      safePrint(e.message);
      return null;
    }
  }

  // Returns followerCount of signed in user
  // Returns a negative value if there is an error
  static Future<int> followerCount() async {
    try {
      final user = await Amplify.Auth.getCurrentUser();
      final id = user.userId;
      final identifier = UserModelIdentifier(id: id);
      final request = ModelQueries.get(User.classType, identifier);
      final response = await Amplify.API.query(request: request).response;
      final userInfo = response.data;
      if (userInfo == null) {
        safePrint("Error getting follower count");
        return -1;
      }
      return userInfo.followerCount ?? -1;
    } on ApiException catch (e) {
      safePrint("fetch failed $e");
      return -1;
    }
  }

  //static Future<User> getUserProfile() async {}
}
